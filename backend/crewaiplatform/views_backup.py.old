from rest_framework import status, viewsets, generics, permissions
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.decorators import action
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model
from django.db import models
import logging
import traceback

from .models import Role, Permission, UserRole, RolePermission
from .models import LLMModel, MCPTool, CrewAIAgent, AgentToolRelation
from .models import Dictionary, DictionaryItem
from .serializers import (
    UserRegisterSerializer, UserSerializer, RoleSerializer, 
    PermissionSerializer, UserRoleSerializer, RolePermissionSerializer,
    # CrewAI相关序列化器
    LLMModelSerializer, LLMModelSimpleSerializer,
    MCPToolSerializer, MCPToolSimpleSerializer,
    CrewAIAgentSerializer, CrewAIAgentSimpleSerializer,
    AgentToolRelationSerializer, AgentToolBindingSerializer,
    LLMModelStatsSerializer, MCPToolStatsSerializer, CrewAIAgentStatsSerializer,
    # 字典管理序列化器
    DictionarySerializer, DictionaryItemSerializer, DictionaryItemSimpleSerializer,
    DictionaryItemTreeSerializer, DictionaryOptionsSerializer
)
from .services import AuthService, RBACService, UserService, RoleService, PermissionService

User = get_user_model()
logger = logging.getLogger(__name__)

class AuthViewSet(APIView):
    """认证相关视图"""
    
    class RegisterView(APIView):
        """用户注册"""
        permission_classes = [permissions.AllowAny]
        
        def post(self, request):
            logger.info(f"注册请求开始 - 数据: {request.data}")
            try:
                # 验证数据
                serializer = UserRegisterSerializer(data=request.data)
                logger.info(f"序列化器创建成功")
                
                if not serializer.is_valid():
                    logger.error(f"数据验证失败: {serializer.errors}")
                    
                    # 处理密码验证错误，提供用户友好的提示
                    if 'password' in serializer.errors:
                        password_errors = serializer.errors['password']
                        friendly_messages = []
                        
                        for error in password_errors:
                            error_code = getattr(error, 'code', '')
                            if 'password_too_common' in str(error) or 'password_too_common' == error_code:
                                friendly_messages.append("密码过于简单，请使用更复杂的密码")
                            elif 'password_entirely_numeric' in str(error) or 'password_entirely_numeric' == error_code:
                                friendly_messages.append("密码不能只包含数字，请添加字母")
                            elif 'password_too_short' in str(error) or 'password_too_short' == error_code:
                                friendly_messages.append("密码长度至少8位")
                            elif 'password_too_similar' in str(error) or 'password_too_similar' == error_code:
                                friendly_messages.append("密码不能与用户名过于相似")
                            else:
                                friendly_messages.append("密码不符合要求，请使用包含字母和数字的8位以上密码")
                        
                        return Response({
                            'detail': '密码验证失败',
                            'errors': {'password': friendly_messages}
                        }, status=status.HTTP_400_BAD_REQUEST)
                    
                    # 处理其他验证错误
                    friendly_errors = {}
                    for field, errors in serializer.errors.items():
                        if field == 'username':
                            if any('already exists' in str(error) or '已存在' in str(error) for error in errors):
                                friendly_errors[field] = ["用户名已存在，请选择其他用户名"]
                            else:
                                friendly_errors[field] = ["用户名格式不正确"]
                        elif field == 'email':
                            friendly_errors[field] = ["邮箱格式不正确"]
                        elif field == 'non_field_errors':
                            if any('不一致' in str(error) for error in errors):
                                friendly_errors['password_confirm'] = ["两次输入的密码不一致"]
                        else:
                            friendly_errors[field] = [str(error) for error in errors]
                    
                    return Response({
                        'detail': '注册信息有误，请检查后重试',
                        'errors': friendly_errors
                    }, status=status.HTTP_400_BAD_REQUEST)
                
                logger.info(f"数据验证成功: {serializer.validated_data}")
                
                # 创建用户
                user = AuthService.register_user(**serializer.validated_data)
                logger.info(f"用户创建成功: {user.username}")
                
                # 生成token
                tokens = AuthService.generate_tokens(user)
                logger.info(f"Token生成成功")
                
                response_data = {
                    **tokens,
                    'user': UserSerializer(user).data
                }
                logger.info(f"注册成功响应: {response_data}")
                
                return Response(response_data, status=status.HTTP_201_CREATED)
                
            except ValueError as e:
                logger.error(f"业务逻辑错误: {str(e)}")
                error_msg = str(e)
                if "用户名已存在" in error_msg:
                    return Response({
                        'detail': '注册失败',
                        'errors': {'username': ['用户名已存在，请选择其他用户名']}
                    }, status=status.HTTP_400_BAD_REQUEST)
                return Response({'detail': error_msg}, status=status.HTTP_400_BAD_REQUEST)
            except Exception as e:
                logger.error(f"注册失败 - 异常: {str(e)}")
                logger.error(f"异常堆栈: {traceback.format_exc()}")
                return Response({'detail': '注册失败，请稍后重试'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    class LoginView(APIView):
        """用户登录"""
        permission_classes = [permissions.AllowAny]
        
        def post(self, request):
            try:
                username = request.data.get('username')
                password = request.data.get('password')
                
                if not username or not password:
                    return Response({'detail': '用户名和密码不能为空'}, status=status.HTTP_400_BAD_REQUEST)
                
                user = AuthService.login_user(username, password)
                tokens = AuthService.generate_tokens(user)
                
                return Response({
                    **tokens,
                    'user': UserSerializer(user).data
                })
                
            except ValueError as e:
                return Response({'detail': str(e)}, status=status.HTTP_401_UNAUTHORIZED)
            except Exception as e:
                return Response({'detail': '登录失败'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    class LogoutView(APIView):
        """用户登出"""
        permission_classes = [permissions.IsAuthenticated]
        
        def post(self, request):
            try:
                refresh_token = request.data.get("refresh")
                if refresh_token:
                    token = RefreshToken(refresh_token)
                    token.blacklist()
                return Response({'detail': '登出成功'}, status=status.HTTP_200_OK)
            except Exception:
                return Response({'detail': '登出失败'}, status=status.HTTP_400_BAD_REQUEST)

class UserInfoView(generics.RetrieveAPIView):
    """获取当前用户信息"""
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        return self.request.user

class UserViewSet(viewsets.ModelViewSet):
    """用户管理视图集"""
    queryset = User.objects.all().order_by('-date_joined')
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取用户统计信息"""
        stats = UserService.get_user_stats()
        return Response(stats)

class RoleViewSet(viewsets.ModelViewSet):
    """角色管理视图集"""
    queryset = Role.objects.all().order_by('name')
    serializer_class = RoleSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取角色统计信息"""
        stats = RoleService.get_role_stats()
        return Response(stats)

class PermissionViewSet(viewsets.ModelViewSet):
    """权限管理视图集"""
    queryset = Permission.objects.all().order_by('name')
    serializer_class = PermissionSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取权限统计信息"""
        stats = PermissionService.get_permission_stats()
        return Response(stats)

class UserRoleViewSet(viewsets.ModelViewSet):
    """用户角色关联管理"""
    queryset = UserRole.objects.select_related('user', 'role').all().order_by('-assigned_at')
    serializer_class = UserRoleSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        try:
            user_id = request.data.get('user')
            role_id = request.data.get('role')
            
            user_role, created = RBACService.assign_role_to_user(user_id, role_id)
            
            if created:
                serializer = self.get_serializer(user_role)
                return Response(serializer.data, status=status.HTTP_201_CREATED)
            else:
                return Response({'detail': '用户已拥有该角色'}, status=status.HTTP_400_BAD_REQUEST)
                
        except Exception as e:
            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)

class RolePermissionViewSet(viewsets.ModelViewSet):
    """角色权限关联管理"""
    queryset = RolePermission.objects.select_related('role', 'permission').all().order_by('-assigned_at')
    serializer_class = RolePermissionSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def create(self, request, *args, **kwargs):
        try:
            role_id = request.data.get('role')
            permission_id = request.data.get('permission')
            
            role_permission, created = RBACService.assign_permission_to_role(role_id, permission_id)
            
            if created:
                serializer = self.get_serializer(role_permission)
                return Response(serializer.data, status=status.HTTP_201_CREATED)
            else:
                return Response({'detail': '角色已拥有该权限'}, status=status.HTTP_400_BAD_REQUEST)
                
        except Exception as e:
            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)

class DashboardView(APIView):
    """仪表盘数据视图"""
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        """获取仪表盘统计数据"""
        try:
            user_stats = UserService.get_user_stats()
            role_stats = RoleService.get_role_stats()
            permission_stats = PermissionService.get_permission_stats()
            
            return Response({
                'userCount': user_stats['total_count'],
                'roleCount': role_stats['total_count'],
                'permissionCount': permission_stats['total_count'],
                'activeUserCount': user_stats['active_count'],
                'staffCount': user_stats['staff_count'],
            })
        except Exception as e:
            return Response({'detail': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# ============================================================================
# CrewAI 集成API视图
# ============================================================================

class LLMModelViewSet(viewsets.ModelViewSet):
    """LLM模型配置管理"""
    queryset = LLMModel.objects.all().order_by('-updated_at', '-is_active', 'name')
    serializer_class = LLMModelSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """过滤查询集"""
        queryset = super().get_queryset()
        
        # 可以根据查询参数过滤
        provider = self.request.query_params.get('provider')
        if provider:
            queryset = queryset.filter(provider=provider)
        
        is_available = self.request.query_params.get('is_available')
        if is_available is not None:
            queryset = queryset.filter(is_available=is_available.lower() == 'true')
        
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def validate_connection(self, request, pk=None):
        """验证LLM模型连接"""
        try:
            model = self.get_object()
            success, message = model.validate_connection()
            
            return Response({
                'success': success,
                'message': message,
                'is_available': model.is_available,
                'last_validated': model.last_validated,
                'validation_error': model.validation_error
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['get'])
    def models(self, request, pk=None):
        """获取提供商可用的模型列表"""
        try:
            from .services import LLMService
            
            model = self.get_object()
            success, message, models_list = LLMService.get_available_models_list(model.id)
            
            if success:
                return Response({
                    'success': True,
                    'models': models_list,
                    'provider': model.provider,
                    'last_updated': model.last_validated
                })
            else:
                return Response({
                    'success': False,
                    'error': message
                }, status=status.HTTP_400_BAD_REQUEST)
                
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['post'])
    def test_connection(self, request):
        """测试连接配置（用于创建前验证）"""
        try:
            from .services import LLMService
            
            # 创建临时模型实例进行测试
            temp_data = request.data.copy()
            
            # 创建临时模型实例
            temp_model = LLMModel(**temp_data)
            
            # 验证连接
            success, message = temp_model.validate_connection()
            
            response_data = {
                'success': success,
                'message': message
            }
            
            # 如果连接成功，尝试获取可用模型列表
            if success:
                try:
                    # 保存临时模型以获取ID
                    temp_model.save()
                    success_models, message_models, models_list = LLMService.get_available_models_list(temp_model.id)
                    
                    if success_models:
                        response_data['available_models'] = models_list
                    
                    # 删除临时模型
                    temp_model.delete()
                    
                except Exception as e:
                    # 如果出错，确保删除临时模型
                    try:
                        temp_model.delete()
                    except:
                        pass
                    logger.warning(f"获取模型列表时出错: {str(e)}")
            
            return Response(response_data)
            
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['post'])
    def batch_validate(self, request):
        """批量验证所有模型"""
        try:
            from .services import LLMService
            
            success, message, results = LLMService.batch_validate_models()
            
            return Response({
                'success': success,
                'message': message,
                'total': results.get('total', 0),
                'available': results.get('available', 0),
                'failed': results.get('failed', 0),
                'details': results.get('details', [])
            })
            
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def available(self, request):
        """获取所有可用的模型"""
        available_models = LLMModel.get_available_models()
        serializer = LLMModelSimpleSerializer(available_models, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取LLM模型统计信息"""
        try:
            total_models = LLMModel.objects.count()
            available_models = LLMModel.objects.filter(is_available=True).count()
            
            # 提供商分布
            provider_dist = {}
            for choice in LLMModel.PROVIDER_CHOICES:
                provider = choice[0]
                count = LLMModel.objects.filter(provider=provider).count()
                if count > 0:
                    provider_dist[choice[1]] = count
            
            # 使用统计（这里可以扩展更多统计）
            usage_stats = {
                'active_models': LLMModel.objects.filter(is_active=True).count(),
                'models_with_errors': LLMModel.objects.exclude(validation_error='').count(),
            }
            
            stats_data = {
                'total_models': total_models,
                'available_models': available_models,
                'provider_distribution': provider_dist,
                'usage_stats': usage_stats
            }
            
            serializer = LLMModelStatsSerializer(stats_data)
            return Response(serializer.data)
            
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class MCPToolViewSet(viewsets.ModelViewSet):
    """MCP工具配置管理"""
    queryset = MCPTool.objects.all().order_by('-created_at')
    serializer_class = MCPToolSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """过滤查询集"""
        queryset = super().get_queryset()
        
        # 可以根据查询参数过滤
        server_type = self.request.query_params.get('server_type')
        if server_type:
            queryset = queryset.filter(server_type=server_type)
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        is_public = self.request.query_params.get('is_public')
        if is_public is not None:
            queryset = queryset.filter(is_public=is_public.lower() == 'true')
        
        # 用户权限过滤
        user = self.request.user
        if not user.is_superuser:
            queryset = MCPTool.get_user_tools(user)
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def health_check(self, request, pk=None):
        """执行工具健康检查"""
        try:
            tool = self.get_object()
            success, message, result = tool.test_connection()
            
            return Response({
                'success': success,
                'message': message,
                'result': result,
                'status': tool.status,
                'last_health_check': tool.last_health_check,
                'response_time_ms': tool.response_time_ms
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def call_tool(self, request, pk=None):
        """调用MCP工具"""
        try:
            tool = self.get_object()
            tool_name = request.data.get('tool_name')
            arguments = request.data.get('arguments', {})
            
            if not tool_name:
                return Response({
                    'error': '缺少tool_name参数'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            success, result = tool.call_tool(tool_name, arguments)
            
            return Response({
                'success': success,
                'result': result,
                'tool_name': tool_name,
                'arguments': arguments
            })
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def healthy(self, request):
        """获取所有健康的工具"""
        healthy_tools = MCPTool.get_healthy_tools()
        serializer = MCPToolSimpleSerializer(healthy_tools, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def public(self, request):
        """获取所有公开工具"""
        public_tools = MCPTool.get_public_tools()
        serializer = MCPToolSimpleSerializer(public_tools, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取MCP工具统计信息"""
        try:
            total_tools = MCPTool.objects.count()
            healthy_tools = MCPTool.objects.filter(status='healthy').count()
            
            # 服务器类型分布
            server_type_dist = {}
            for choice in MCPTool.SERVER_TYPE_CHOICES:
                server_type = choice[0]
                count = MCPTool.objects.filter(server_type=server_type).count()
                if count > 0:
                    server_type_dist[choice[1]] = count
            
            # 使用统计
            usage_stats = {
                'active_tools': MCPTool.objects.filter(is_active=True).count(),
                'public_tools': MCPTool.objects.filter(is_public=True).count(),
                'tools_with_errors': MCPTool.objects.filter(status='error').count(),
            }
            
            stats_data = {
                'total_tools': total_tools,
                'healthy_tools': healthy_tools,
                'server_type_distribution': server_type_dist,
                'usage_stats': usage_stats
            }
            
            serializer = MCPToolStatsSerializer(stats_data)
            return Response(serializer.data)
            
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class CrewAIAgentViewSet(viewsets.ModelViewSet):
    """CrewAI Agent配置管理"""
    queryset = CrewAIAgent.objects.select_related('llm_model', 'function_calling_llm', 'owner').all().order_by('-created_at')
    serializer_class = CrewAIAgentSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """过滤查询集"""
        queryset = super().get_queryset()
        
        # 可以根据查询参数过滤
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        is_public = self.request.query_params.get('is_public')
        if is_public is not None:
            queryset = queryset.filter(is_public=is_public.lower() == 'true')
        
        # 用户权限过滤
        user = self.request.user
        if not user.is_superuser:
            queryset = CrewAIAgent.get_user_agents(user)
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def start(self, request, pk=None):
        """启动Agent"""
        try:
            agent = self.get_object()
            success, message = agent.start()
            
            return Response({
                'success': success,
                'message': message,
                'status': agent.status
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def stop(self, request, pk=None):
        """停止Agent"""
        try:
            agent = self.get_object()
            success, message = agent.stop()
            
            return Response({
                'success': success,
                'message': message,
                'status': agent.status
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def pause(self, request, pk=None):
        """暂停Agent"""
        try:
            agent = self.get_object()
            success, message = agent.pause()
            
            return Response({
                'success': success,
                'message': message,
                'status': agent.status
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def resume(self, request, pk=None):
        """恢复Agent"""
        try:
            agent = self.get_object()
            success, message = agent.resume()
            
            return Response({
                'success': success,
                'message': message,
                'status': agent.status
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def execute_task(self, request, pk=None):
        """执行任务"""
        try:
            agent = self.get_object()
            task_description = request.data.get('task_description')
            context = request.data.get('context')
            
            if not task_description:
                return Response({
                    'error': '缺少task_description参数'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            success, result = agent.execute_task(task_description, context)
            
            return Response({
                'success': success,
                'result': result,
                'task_description': task_description,
                'status': agent.status,
                'total_tasks': agent.total_tasks,
                'completed_tasks': agent.completed_tasks
            })
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['get'])
    def tools(self, request, pk=None):
        """获取Agent绑定的工具"""
        try:
            agent = self.get_object()
            relations = AgentToolRelation.get_agent_tools(agent)
            serializer = AgentToolRelationSerializer(relations, many=True)
            return Response(serializer.data)
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def bind_tools(self, request, pk=None):
        """批量绑定工具"""
        try:
            agent = self.get_object()
            serializer = AgentToolBindingSerializer(data=request.data)
            
            if not serializer.is_valid():
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
            
            tool_ids = serializer.validated_data['tool_ids']
            permission_level = serializer.validated_data['permission_level']
            
            # 批量创建关联
            created_relations = []
            for tool_id in tool_ids:
                try:
                    tool = MCPTool.objects.get(id=tool_id, is_active=True)
                    relation, created = AgentToolRelation.objects.get_or_create(
                        agent=agent,
                        tool=tool,
                        defaults={'permission_level': permission_level}
                    )
                    if created:
                        created_relations.append(relation)
                except MCPTool.DoesNotExist:
                    continue
            
            # 返回创建的关联
            result_serializer = AgentToolRelationSerializer(created_relations, many=True)
            return Response({
                'success': True,
                'message': f'成功绑定 {len(created_relations)} 个工具',
                'relations': result_serializer.data
            })
            
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def active(self, request):
        """获取所有活跃的Agent"""
        active_agents = CrewAIAgent.get_active_agents()
        serializer = CrewAIAgentSimpleSerializer(active_agents, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def public(self, request):
        """获取所有公开Agent"""
        public_agents = CrewAIAgent.get_public_agents()
        serializer = CrewAIAgentSimpleSerializer(public_agents, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取Agent统计信息"""
        try:
            total_agents = CrewAIAgent.objects.count()
            active_agents = CrewAIAgent.objects.filter(status__in=['active', 'running']).count()
            
            # 任务统计
            task_stats = {
                'total_tasks': CrewAIAgent.objects.aggregate(
                    total=models.Sum('total_tasks'))['total'] or 0,
                'completed_tasks': CrewAIAgent.objects.aggregate(
                    completed=models.Sum('completed_tasks'))['completed'] or 0,
            }
            if task_stats['total_tasks'] > 0:
                task_stats['success_rate'] = (task_stats['completed_tasks'] / task_stats['total_tasks']) * 100
            else:
                task_stats['success_rate'] = 0
            
            # 性能统计
            performance_stats = {
                'agents_with_tasks': CrewAIAgent.objects.filter(total_tasks__gt=0).count(),
                'agents_with_errors': CrewAIAgent.objects.exclude(last_error='').count(),
            }
            
            stats_data = {
                'total_agents': total_agents,
                'active_agents': active_agents,
                'task_stats': task_stats,
                'performance_stats': performance_stats
            }
            
            serializer = CrewAIAgentStatsSerializer(stats_data)
            return Response(serializer.data)
            
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class AgentToolRelationViewSet(viewsets.ModelViewSet):
    """Agent-Tool关联管理"""
    queryset = AgentToolRelation.objects.select_related('agent', 'tool').all().order_by('agent', 'order')
    serializer_class = AgentToolRelationSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """过滤查询集"""
        queryset = super().get_queryset()
        
        # 可以根据查询参数过滤
        agent_id = self.request.query_params.get('agent_id')
        if agent_id:
            queryset = queryset.filter(agent_id=agent_id)
        
        tool_id = self.request.query_params.get('tool_id')
        if tool_id:
            queryset = queryset.filter(tool_id=tool_id)
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        # 用户权限过滤
        user = self.request.user
        if not user.is_superuser:
            queryset = queryset.filter(agent__owner=user)
        
        return queryset
    
    @action(detail=True, methods=['post'])
    def test_connection(self, request, pk=None):
        """测试工具连接"""
        try:
            relation = self.get_object()
            success, message = relation.test_connection()
            
            return Response({
                'success': success,
                'message': message,
                'status': relation.status,
                'last_error': relation.last_error
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def activate(self, request, pk=None):
        """激活关联"""
        try:
            relation = self.get_object()
            success, message = relation.activate()
            
            return Response({
                'success': success,
                'message': message,
                'status': relation.status
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=True, methods=['post'])
    def deactivate(self, request, pk=None):
        """停用关联"""
        try:
            relation = self.get_object()
            success, message = relation.deactivate()
            
            return Response({
                'success': success,
                'message': message,
                'status': relation.status
            })
        except Exception as e:
            return Response({
                'success': False,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def high_usage(self, request):
        """获取高使用频率的关联"""
        min_calls = int(request.query_params.get('min_calls', 100))
        relations = AgentToolRelation.get_high_usage_relations(min_calls)
        serializer = self.get_serializer(relations, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def problematic(self, request):
        """获取问题关联（成功率低）"""
        max_success_rate = float(request.query_params.get('max_success_rate', 80))
        relations = AgentToolRelation.get_problematic_relations(max_success_rate)
        serializer = self.get_serializer(relations, many=True)
        return Response(serializer.data)


# ============================================================================
# 字典管理视图
# ============================================================================

class DictionaryViewSet(viewsets.ModelViewSet):
    """字典类型管理ViewSet"""
    queryset = Dictionary.objects.all().order_by('sort_order', 'created_at')
    serializer_class = DictionarySerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """获取查询集"""
        queryset = super().get_queryset()
        
        # 根据激活状态过滤
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        # 根据代码搜索
        code = self.request.query_params.get('code')
        if code:
            queryset = queryset.filter(code__icontains=code)
        
        # 根据名称搜索
        name = self.request.query_params.get('name')
        if name:
            queryset = queryset.filter(name__icontains=name)
        
        return queryset
    
    @action(detail=True, methods=['get'])
    def items(self, request, pk=None):
        """获取字典的所有项目"""
        try:
            dictionary = self.get_object()
            
            # 获取查询参数
            parent_only = request.query_params.get('parent_only', 'false').lower() == 'true'
            tree_format = request.query_params.get('tree_format', 'false').lower() == 'true'
            
            if parent_only:
                # 只获取一级项目（无父级的项目）
                items = dictionary.items.filter(parent__isnull=True, is_active=True).order_by('sort_order', 'name')
            else:
                # 获取所有项目
                items = dictionary.items.filter(is_active=True).order_by('sort_order', 'name')
            
            if tree_format:
                # 树形结构返回
                serializer = DictionaryItemTreeSerializer(items, many=True)
            else:
                # 列表结构返回
                serializer = DictionaryItemSimpleSerializer(items, many=True)
            
            return Response(serializer.data)
        except Exception as e:
            logger.error(f"获取字典项目失败: {str(e)}")
            return Response({
                'error': f'获取字典项目失败: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def options(self, request):
        """获取字典选项，用于前端下拉选择"""
        try:
            dictionary_code = request.query_params.get('code')
            parent_code = request.query_params.get('parent_code')
            
            if not dictionary_code:
                return Response({
                    'error': '缺少字典代码参数'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # 获取字典类型
            try:
                dictionary = Dictionary.objects.get(code=dictionary_code, is_active=True)
            except Dictionary.DoesNotExist:
                return Response({
                    'error': '字典类型不存在或未激活'
                }, status=status.HTTP_404_NOT_FOUND)
            
            # 构建查询条件
            query = {'dictionary': dictionary, 'is_active': True}
            
            if parent_code:
                # 获取指定父级下的子项目
                try:
                    parent = DictionaryItem.objects.get(
                        dictionary=dictionary, 
                        code=parent_code, 
                        is_active=True
                    )
                    query['parent'] = parent
                except DictionaryItem.DoesNotExist:
                    return Response({
                        'error': '父级字典项不存在或未激活'
                    }, status=status.HTTP_404_NOT_FOUND)
            else:
                # 获取一级项目（无父级）
                query['parent__isnull'] = True
            
            # 查询字典项
            items = DictionaryItem.objects.filter(**query).order_by('sort_order', 'name')
            serializer = DictionaryItemSimpleSerializer(items, many=True)
            
            return Response({
                'dictionary': {
                    'code': dictionary.code,
                    'name': dictionary.name
                },
                'items': serializer.data
            })
        except Exception as e:
            logger.error(f"获取字典选项失败: {str(e)}")
            return Response({
                'error': f'获取字典选项失败: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """获取字典统计信息"""
        try:
            total_dictionaries = Dictionary.objects.count()
            active_dictionaries = Dictionary.objects.filter(is_active=True).count()
            total_items = DictionaryItem.objects.count()
            active_items = DictionaryItem.objects.filter(is_active=True).count()
            
            # 字典类型分布
            dictionary_distribution = {}
            dictionaries = Dictionary.objects.filter(is_active=True)
            for dictionary in dictionaries:
                item_count = dictionary.items.filter(is_active=True).count()
                dictionary_distribution[dictionary.name] = item_count
            
            return Response({
                'total_dictionaries': total_dictionaries,
                'active_dictionaries': active_dictionaries,
                'total_items': total_items,
                'active_items': active_items,
                'dictionary_distribution': dictionary_distribution,
            })
        except Exception as e:
            logger.error(f"获取字典统计信息失败: {str(e)}")
            return Response({
                'error': f'获取字典统计信息失败: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class DictionaryItemViewSet(viewsets.ModelViewSet):
    """字典项管理ViewSet"""
    queryset = DictionaryItem.objects.all().order_by('sort_order', 'created_at')
    serializer_class = DictionaryItemSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """获取查询集"""
        queryset = super().get_queryset()
        
        # 根据字典类型过滤
        dictionary_id = self.request.query_params.get('dictionary_id')
        if dictionary_id:
            queryset = queryset.filter(dictionary_id=dictionary_id)
        
        dictionary_code = self.request.query_params.get('dictionary_code')
        if dictionary_code:
            queryset = queryset.filter(dictionary__code=dictionary_code)
        
        # 根据父级过滤
        parent_id = self.request.query_params.get('parent_id')
        if parent_id:
            queryset = queryset.filter(parent_id=parent_id)
        elif self.request.query_params.get('parent_only', 'false').lower() == 'true':
            queryset = queryset.filter(parent__isnull=True)
        
        # 根据激活状态过滤
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        # 根据代码搜索
        code = self.request.query_params.get('code')
        if code:
            queryset = queryset.filter(code__icontains=code)
        
        # 根据名称搜索
        name = self.request.query_params.get('name')
        if name:
            queryset = queryset.filter(name__icontains=name)
        
        return queryset
    
    @action(detail=True, methods=['get'])
    def children(self, request, pk=None):
        """获取字典项的子项目"""
        try:
            parent = self.get_object()
            children = parent.get_children()
            serializer = DictionaryItemSimpleSerializer(children, many=True)
            return Response(serializer.data)
        except Exception as e:
            logger.error(f"获取子项目失败: {str(e)}")
            return Response({
                'error': f'获取子项目失败: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['post'])
    def batch_create(self, request):
        """批量创建字典项"""
        try:
            items_data = request.data.get('items', [])
            if not items_data:
                return Response({
                    'error': '缺少字典项数据'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            created_items = []
            errors = []
            
            for item_data in items_data:
                serializer = self.get_serializer(data=item_data)
                if serializer.is_valid():
                    item = serializer.save()
                    created_items.append(serializer.data)
                else:
                    errors.append({
                        'data': item_data,
                        'errors': serializer.errors
                    })
            
            return Response({
                'success': True,
                'created_count': len(created_items),
                'created_items': created_items,
                'error_count': len(errors),
                'errors': errors
            })
        except Exception as e:
            logger.error(f"批量创建字典项失败: {str(e)}")
            return Response({
                'error': f'批量创建字典项失败: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    @action(detail=False, methods=['get'])
    def tree(self, request):
        """获取树形结构的字典项"""
        try:
            dictionary_code = request.query_params.get('dictionary_code')
            if not dictionary_code:
                return Response({
                    'error': '缺少字典代码参数'
                }, status=status.HTTP_400_BAD_REQUEST)
            
            try:
                dictionary = Dictionary.objects.get(code=dictionary_code, is_active=True)
            except Dictionary.DoesNotExist:
                return Response({
                    'error': '字典类型不存在或未激活'
                }, status=status.HTTP_404_NOT_FOUND)
            
            # 获取一级项目（根节点）
            root_items = DictionaryItem.objects.filter(
                dictionary=dictionary, 
                parent__isnull=True, 
                is_active=True
            ).order_by('sort_order', 'name')
            
            serializer = DictionaryItemTreeSerializer(root_items, many=True)
            
            return Response({
                'dictionary': {
                    'code': dictionary.code,
                    'name': dictionary.name
                },
                'tree': serializer.data
            })
        except Exception as e:
            logger.error(f"获取树形结构失败: {str(e)}")
            return Response({
                'error': f'获取树形结构失败: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)